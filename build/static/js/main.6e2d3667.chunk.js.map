{"version":3,"sources":["components/Node.js","components/ControlBar.js","components/Footer.js","algorithms/dijkstra.js","algorithms/bfs.js","algorithms/dfs.js","components/MazeSolver.js","App.js","index.js"],"names":["Node","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","extraClassName","id","className","style","color","margin","fontSize","ControlBar","resetGrid","algorithm","resetAlgorithm","visualizeAlgorithm","map","title","mapTitle","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","Nav","NavDropdown","Item","onClick","Link","Footer","backgroundColor","opacity","target","dijkstra","grid","startNode","finishNode","nodesVisitedInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","visited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisited","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","animateDijkstra","orderedVisitedNodes","orderedNodesOnShortestPath","i","setTimeout","document","getElementById","animateShortestPath","animateBfs","visualizeBfs","startRow","startCol","finishRow","finishCol","unvisitedNeighbors","times","currNode","console","log","includes","bfs","shortestPath","currentNode","unshift","getShortestNodePath","animateDfs","visualizeDfs","toBeVisitedNodes","pop","dfs","MazeSolver","useState","setGrid","mouseIsPressed","setMouseIsPressed","dragStart","setDragStart","dragFinish","setDragFinish","NODE_START_ROW","setStartRow","NODE_START_COL","setStartCol","NODE_FINISH_ROW","setFinishRow","NODE_FINISH_COL","setFinishCol","setAlgorithm","useEffect","initializeGrid","newGrid","str","visualizeDijkstra","rowIdx","key","nodeIdx","initializeGridWithWall","handleMouseDown","initializeGridWithNewStart","initializeGridWithNewFinish","handleMouseEnter","handleMouseLeave","currentRow","createNode","slice","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.6e2d3667.chunk.js","sourcesContent":["import React from 'react';\nimport { FaRegStar } from 'react-icons/fa';\nimport { FiTarget } from 'react-icons/fi'\nimport './styles/Node.css';\n\nexport const Node = props => {\n    let {\n        row,\n        col,\n        isStart,\n        isFinish,\n        isWall,\n        onMouseDown,\n        onMouseUp,\n        onMouseEnter,\n        onMouseLeave\n    } = props;\n\n    const extraClassName = isWall ? 'node-wall' : '';\n\n    return (\n        <div\n            id={`node-${row}-${col}`}\n            className={`node ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseLeave={() => onMouseLeave(row, col)}\n            onMouseUp={() => onMouseUp()}\n            style={{ color: \"red\" }}\n        >\n            {isStart ? <FaRegStar style={{ margin: \"2px 0 0 2px\", color: \"red\", fontSize: \"2.6rem\" }} /> : \"\"}\n            {isFinish ? <FiTarget style={{ margin: \"2px 0 0 2px\", color: \"red\", fontSize: \"2.6rem\" }} /> : \"\"}\n        </div>\n    )\n}","import React from 'react';\nimport Navbar from 'react-bootstrap/Navbar';\nimport Nav from 'react-bootstrap/Nav';\nimport NavDropdown from 'react-bootstrap/NavDropdown';\n\nimport \"./styles/ControlBar.css\";\n\nexport const ControlBar = props => {\n    const { resetGrid, algorithm, resetAlgorithm, visualizeAlgorithm, map } = props;\n    const title = algorithm ? algorithm : \"Select Algorithm\";\n    const mapTitle = map ? map : \"Select a Map\"\n    return (\n        <Navbar collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\" className=\"control-bar-container\">\n            <Navbar.Brand href=\"#\" className=\"control-bar-container-title\">Pathfinding Visualizer</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n                <Nav className=\"mr-auto\">\n                    <NavDropdown title={title} id=\"collasible-nav-dropdown\" className=\"control-bar-button\" variant=\"outline-light\">\n                        <NavDropdown.Item onClick={() => resetAlgorithm('dijkstra')}>See Dijkstra's Algorithm</NavDropdown.Item>\n                        <NavDropdown.Item onClick={() => resetAlgorithm('dfs')}>See DFS Algorithm</NavDropdown.Item>\n                        <NavDropdown.Item onClick={() => resetAlgorithm('bfs')}>See BFS Algorithm</NavDropdown.Item>\n                    </NavDropdown>\n                    <NavDropdown title={mapTitle} id=\"collasible-nav-dropdown\" className=\"control-bar-button\">\n                        <NavDropdown.Item>Map1</NavDropdown.Item>\n                        <NavDropdown.Item>Map2</NavDropdown.Item>\n                        <NavDropdown.Item>Map3</NavDropdown.Item>\n                    </NavDropdown>\n                    <Nav.Link className=\"control-bar-button\" onClick={() => visualizeAlgorithm()}>Start!</Nav.Link>\n                    <Nav.Link onClick={() => resetGrid()} className=\"control-bar-button\">Reset Grid</Nav.Link>\n                    <Nav.Link className=\"control-bar-button\">Instructions</Nav.Link>\n                </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}","import React from 'react';\nimport \"./styles/Footer.css\";\n\nexport const Footer = () => {\n    return (\n        <div className=\"footer-container\">\n            <p style={{ backgroundColor: \"white\", opacity: \"80%\" }}>Created by Jonathan Chen, hosted on <a href=\"https://github.com/jonathanthec/maze-solver\" target=\"__blank\">Github</a></p>\n        </div>\n    )\n}","// Dijkstra's algorithm will return all nodes that are visited\n// Order of visiting is top, right, bottom, left\n// All nodes point to their previous node, giving us the shortest path\n\nexport function dijkstra(grid, startNode, finishNode) {\n    // Keep track of a list of nodes that I have visited in order\n    const nodesVisitedInOrder = [];\n    // The distance to startNode from startNode is 0\n    startNode.distance = 0;\n    // Get all unvisited nodes in the grid (here it's all nodes)\n    const unvisitedNodes = getAllNodes(grid);\n    // Now, as long as we still have unvisited nodes in the above list\n    while (unvisitedNodes.length !== 0) {\n        // Sort the list of unvisited nodes to place the one with shortest distance \n        // In the front. This ensures startNode is at beginning. \n        sortNodesByDistance(unvisitedNodes);\n        // Returns the first node in the list unvisitedNodes and removes it from list\n        const closestNode = unvisitedNodes.shift();\n        // If a node is wall, continue\n        if (closestNode.isWall === true) continue;\n        // If a node's distance to startNode is infinity, we are done, no more places to go\n        if (closestNode.distance === Infinity) {\n            return nodesVisitedInOrder;\n        }\n        // Otherwise, do the following\n        closestNode.visited = true;\n        nodesVisitedInOrder.push(closestNode);\n        if (closestNode === finishNode) {\n            return nodesVisitedInOrder;\n        }\n        // See what are the neighbors of closestNode, and update their distance to startNode\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisited = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisited) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nfunction getShortestNodePath(finishNode) {\n    const shortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\nfunction animateDijkstra(orderedVisitedNodes, orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedVisitedNodes.length; i++) {\n        if (i === orderedVisitedNodes.length - 1) {\n            setTimeout(() => {\n                animateShortestPath(orderedNodesOnShortestPath);\n            }, 10 * i);\n        }\n        setTimeout(() => {\n            const node = orderedVisitedNodes[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n    }\n}\n\nfunction animateShortestPath(orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedNodesOnShortestPath.length; i++) {\n        setTimeout(() => {\n            const node = orderedNodesOnShortestPath[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }, 50 * i)\n    }\n}\n\nexport function visualizeDijkstra(grid, startRow, startCol, finishRow, finishCol) {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const orderedVisitedNodes = dijkstra(grid, startNode, finishNode);\n    const orderedNodesOnShortestPath = getShortestNodePath(finishNode);\n    animateDijkstra(orderedVisitedNodes, orderedNodesOnShortestPath);\n}","// Breadth first search algorithm will start at a node, list all\n// of the node's neighbors in an array, and check each of the neighbors, \n// while adding neighbor's neighbors in the list\n// Does not guarantee the shortest path for obvious reason\n\nexport function bfs(grid, startNode, finishNode) {\n    // Initialize an empty array to track nodes that I will be visiting in order\n    const nodesVisitedInOrder = [];\n    // Initialize an empty queue, this will keep track all the nodes we haven't visit yet\n    const unvisitedNeighbors = [];\n    // And push startNode to it, because we will start at startNode\n    unvisitedNeighbors.push(startNode);\n    let times = 0;\n    // As long as finishNode isn't found, we'll keep searching until there are no more things to look for\n    while (unvisitedNeighbors.length > 0) {\n        times++;\n        // Grab the first node on unvisitedNeighbors, and its row and col\n        const currNode = unvisitedNeighbors.shift();\n        if (currNode.isWall) continue;\n        if (!currNode.visited) {\n            currNode.visited = true;\n            nodesVisitedInOrder.push(currNode);\n        }\n        // Now, if currNode is the finishNode, we are done\n        if (currNode === finishNode) {\n            console.log(times)\n            return nodesVisitedInOrder;\n        }\n        // Otherwise we need to push its unvisited neighbors to unvisitedNeighbors\n        const neighbors = getUnvisitedNeighbors(currNode, grid);\n        for (let i = 0; i < neighbors.length; i++) {\n            if (neighbors[i].visited === false && !unvisitedNeighbors.includes(neighbors[i])) {\n                neighbors[i].previousNode = currNode;\n                unvisitedNeighbors.push(neighbors[i]);\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nfunction getShortestNodePath(finishNode) {\n    const shortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\nfunction animateBfs(orderedVisitedNodes, orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedVisitedNodes.length; i++) {\n        if (i === orderedVisitedNodes.length - 1) {\n            setTimeout(() => {\n                animateShortestPath(orderedNodesOnShortestPath);\n            }, 10 * i);\n        }\n        setTimeout(() => {\n            const node = orderedVisitedNodes[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n    }\n}\n\nfunction animateShortestPath(orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedNodesOnShortestPath.length; i++) {\n        setTimeout(() => {\n            const node = orderedNodesOnShortestPath[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }, 50 * i)\n    }\n}\n\nexport function visualizeBfs(grid, startRow, startCol, finishRow, finishCol) {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const orderedVisitedNodes = bfs(grid, startNode, finishNode);\n    const orderedNodesOnShortestPath = getShortestNodePath(finishNode);\n    animateBfs(orderedVisitedNodes, orderedNodesOnShortestPath);\n}","// Depth first search algorithm will start at startNode, and add all of its valid neighbors\n// To an array called toBeVisitedNodes. Order of adding neighbors will be top, right, bottom, left.\n// It will then check for the last element in the array.\n// Does not guarantee shortest path.\n\nexport function dfs(grid, startNode, finishNode) {\n    const toBeVisitedNodes = [];\n    const nodesVisitedInOrder = [];\n    toBeVisitedNodes.push(startNode);\n\n    while (toBeVisitedNodes.length > 0) {\n        const currNode = toBeVisitedNodes.pop();\n        if (currNode.isWall === true) continue;\n        if (!currNode.visited) {\n            currNode.visited = true;\n            nodesVisitedInOrder.push(currNode);\n        }\n        if (currNode === finishNode) {\n            return nodesVisitedInOrder;\n        }\n        const neighbors = getUnvisitedNeighbors(currNode, grid);\n        for (const neighbor of neighbors) {\n            if (!toBeVisitedNodes.includes(neighbor)) {\n                neighbor.previousNode = currNode;\n                toBeVisitedNodes.push(neighbor);\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nfunction getShortestNodePath(finishNode) {\n    const shortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\n\nfunction animateDfs(orderedVisitedNodes, orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedVisitedNodes.length; i++) {\n        if (i === orderedVisitedNodes.length - 1) {\n            setTimeout(() => {\n                animateShortestPath(orderedNodesOnShortestPath);\n            }, 10 * i);\n        }\n        setTimeout(() => {\n            const node = orderedVisitedNodes[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n    }\n}\n\nfunction animateShortestPath(orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedNodesOnShortestPath.length; i++) {\n        setTimeout(() => {\n            const node = orderedNodesOnShortestPath[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }, 50 * i)\n    }\n}\n\nexport function visualizeDfs(grid, startRow, startCol, finishRow, finishCol) {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const orderedVisitedNodes = dfs(grid, startNode, finishNode);\n    const orderedNodesOnShortestPath = getShortestNodePath(finishNode);\n    animateDfs(orderedVisitedNodes, orderedNodesOnShortestPath);\n}","import React, { useState, useEffect } from 'react';\nimport { Node } from './Node.js';\nimport { ControlBar } from './ControlBar.js';\nimport { Footer } from './Footer.js';\nimport { visualizeDijkstra } from '../algorithms/dijkstra';\nimport { visualizeBfs } from '../algorithms/bfs';\nimport { visualizeDfs } from '../algorithms/dfs';\nimport './styles/MazeSolver.css';\n\nexport default function MazeSolver() {\n    const [grid, setGrid] = useState([]);\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\n    const [dragStart, setDragStart] = useState(false);\n    const [dragFinish, setDragFinish] = useState(false);\n    const [startRow, setStartRow] = useState(NODE_START_ROW);\n    const [startCol, setStartCol] = useState(NODE_START_COL);\n    const [finishRow, setFinishRow] = useState(NODE_FINISH_ROW);\n    const [finishCol, setFinishCol] = useState(NODE_FINISH_COL);\n    const [algorithm, setAlgorithm] = useState(null);\n\n    useEffect(() => {\n        const grid = initializeGrid();\n        setGrid(grid);\n    }, [])\n\n    function resetGrid() {\n        for (let row = 0; row < 26; row++) {\n            for (let col = 0; col < 51; col++) {\n                document.getElementById(`node-${row}-${col}`).className = 'node';\n            }\n        }\n        const newGrid = initializeGrid();\n        setGrid(newGrid);\n        setStartRow(NODE_START_ROW);\n        setStartCol(NODE_START_COL);\n        setFinishRow(NODE_FINISH_ROW);\n        setFinishCol(NODE_FINISH_COL);\n    }\n\n    function resetAlgorithm(str) {\n        setAlgorithm(str);\n    }\n\n    function handleMouseDown(row, col) {\n        if (grid[row][col].isStart) {\n            setDragStart(true);\n            setMouseIsPressed(true);\n        }\n        if (grid[row][col].isFinish) {\n            setDragFinish(true);\n            setMouseIsPressed(true);\n        }\n        if (!grid[row][col].isFinish && !grid[row][col].isStart) {\n            const newGrid = initializeGridWithWall(grid, row, col);\n            setGrid(newGrid);\n            setMouseIsPressed(true);\n        }\n    }\n\n    function handleMouseEnter(row, col) {\n        if (!mouseIsPressed && !dragStart && !dragFinish) return;\n        if (dragStart) {\n            const newGrid = initializeGridWithNewStart(grid, row, col);\n            setGrid(newGrid);\n            setStartRow(row);\n            setStartCol(col);\n        }\n        if (dragFinish) {\n            const newGrid = initializeGridWithNewFinish(grid, row, col);\n            setGrid(newGrid);\n            setFinishRow(row);\n            setFinishCol(col);\n        }\n        if (!dragStart && !dragFinish) {\n            const newGrid = initializeGridWithWall(grid, row, col);\n            setGrid(newGrid);\n        }\n    }\n\n    function handleMouseLeave(row, col) {\n        if (dragStart) {\n            const newGrid = initializeGridWithNewStart(grid, row, col);\n            setGrid(newGrid);\n        }\n        if (dragFinish) {\n            const newGrid = initializeGridWithNewFinish(grid, row, col);\n            setGrid(newGrid);\n        }\n        if (!dragStart && !dragFinish) {\n            return;\n        }\n    }\n\n    function handleMouseUp() {\n        setMouseIsPressed(false);\n        setDragStart(false);\n        setDragFinish(false);\n    }\n\n    function visualizeAlgorithm() {\n        if (algorithm === 'dijkstra') {\n            visualizeDijkstra(grid, startRow, startCol, finishRow, finishCol);\n        }\n        if (algorithm === 'bfs') {\n            visualizeBfs(grid, startRow, startCol, finishRow, finishCol);\n        }\n        if (algorithm === 'dfs') {\n            visualizeDfs(grid, startRow, startCol, finishRow, finishCol);\n        }\n    }\n\n    return (\n        <div className=\"page-container\">\n            <ControlBar\n                resetGrid={resetGrid}\n                resetAlgorithm={resetAlgorithm}\n                algorithm={algorithm}\n                visualizeAlgorithm={visualizeAlgorithm}\n            />\n            <div className=\"page-main\"> {/************ START OF MAIN CONTENT ************/}\n                <div className=\"grid\">\n                    {grid && grid.map((row, rowIdx) => {\n                        return (\n                            <div key={rowIdx} className=\"grid-row\">\n                                {row.map((node, nodeIdx) => {\n                                    const { row, col, isStart, isFinish, isWall } = node;\n                                    return (\n                                        <Node\n                                            key={nodeIdx}\n                                            row={row}\n                                            col={col}\n                                            isStart={isStart}\n                                            isFinish={isFinish}\n                                            isWall={isWall}\n                                            mouseIsPressed={mouseIsPressed}\n                                            onMouseDown={(row, col) => handleMouseDown(row, col)}\n                                            onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                                            onMouseLeave={(row, col) => handleMouseLeave(row, col)}\n                                            onMouseUp={() => handleMouseUp()}\n                                        />\n                                    )\n                                })}\n                            </div>\n                        );\n                    })}\n                </div>\n            </div> {/************ END OF MAIN CONTENT ************/}\n            <Footer />\n        </div>\n    )\n}\n\nconst NODE_START_ROW = 10\nconst NODE_START_COL = 5;\nconst NODE_FINISH_ROW = 10;\nconst NODE_FINISH_COL = 20;\n\nfunction initializeGrid() {\n    const grid = [];\n    for (let row = 0; row < 26; row++) {\n        const currentRow = [];\n        for (let col = 0; col < 51; col++) {\n            currentRow.push(createNode(row, col));\n        }\n        grid.push(currentRow);\n    }\n    return grid;\n}\n\nfunction createNode(row, col) {\n    return {\n        row,\n        col,\n        isStart: row === NODE_START_ROW && col === NODE_START_COL,\n        isFinish: row === NODE_FINISH_ROW && col === NODE_FINISH_COL,\n        isWall: false,\n        visited: false,\n        distance: Infinity,\n        previousNode: null\n    }\n}\n\nconst initializeGridWithWall = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isFinish) {\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n    }\n    return newGrid;\n};\n\nconst initializeGridWithNewStart = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isStart: !node.isStart,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n};\n\nconst initializeGridWithNewFinish = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isFinish: !node.isFinish,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n};","import React from 'react';\nimport MazeSolver from './components/MazeSolver.js';\n\nfunction App() {\n  return (\n    <MazeSolver />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}