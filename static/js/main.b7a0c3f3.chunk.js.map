{"version":3,"sources":["components/Node.js","components/ControlBar.js","components/InfoSection.js","components/Footer.js","algorithms/dijkstra.js","algorithms/bfs.js","algorithms/dfs.js","components/MazeSolver.js","App.js","index.js"],"names":["Node","props","row","col","isStart","isFinish","isWall","onMouseDown","onMouseUp","onMouseEnter","onMouseLeave","extraClassName","id","className","style","color","margin","fontSize","ControlBar","resetGrid","algorithm","resetAlgorithm","visualizeAlgorithm","title","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","Toggle","aria-controls","Collapse","Nav","NavDropdown","Item","onClick","Link","InfoSection","Footer","target","rel","dijkstra","grid","startNode","finishNode","nodesVisitedInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","visited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisited","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","animateDijkstra","orderedVisitedNodes","orderedNodesOnShortestPath","i","setTimeout","document","getElementById","animateShortestPath","animateBfs","visualizeBfs","startRow","startCol","finishRow","finishCol","unvisitedNeighbors","times","currNode","console","log","includes","bfs","shortestPath","currentNode","unshift","getShortestNodePath","animateDfs","visualizeDfs","toBeVisitedNodes","pop","dfs","MazeSolver","useState","setGrid","mouseIsPressed","setMouseIsPressed","dragStart","setDragStart","dragFinish","setDragFinish","NODE_START_ROW","setStartRow","NODE_START_COL","setStartCol","NODE_FINISH_ROW","setFinishRow","NODE_FINISH_COL","setFinishCol","setAlgorithm","useEffect","initializeGrid","newGrid","str","visualizeDijkstra","map","rowIdx","key","nodeIdx","initializeGridWithWall","handleMouseDown","initializeGridWithNewStart","initializeGridWithNewFinish","handleMouseEnter","handleMouseLeave","currentRow","createNode","slice","newNode","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b7a0c3f3.chunk.js","sourcesContent":["import React from 'react';\nimport { FaRegStar } from 'react-icons/fa';\nimport { FiTarget } from 'react-icons/fi'\nimport './styles/Node.css';\n\nexport const Node = props => {\n    let {\n        row,\n        col,\n        isStart,\n        isFinish,\n        isWall,\n        onMouseDown,\n        onMouseUp,\n        onMouseEnter,\n        onMouseLeave\n    } = props;\n\n    const extraClassName = isWall ? 'node-wall' : '';\n\n    return (\n        <div\n            id={`node-${row}-${col}`}\n            className={`node ${extraClassName}`}\n            onMouseDown={() => onMouseDown(row, col)}\n            onMouseEnter={() => onMouseEnter(row, col)}\n            onMouseLeave={() => onMouseLeave(row, col)}\n            onMouseUp={() => onMouseUp()}\n            style={{ color: \"red\" }}\n        >\n            {isStart ? <FaRegStar style={{ margin: \"2px 0 0 2px\", color: \"red\", fontSize: \"1.6rem\" }} /> : \"\"}\n            {isFinish ? <FiTarget style={{ margin: \"2px 0 0 2px\", color: \"red\", fontSize: \"1.6rem\" }} /> : \"\"}\n        </div>\n    )\n}","import React from 'react';\nimport Navbar from 'react-bootstrap/Navbar';\nimport Nav from 'react-bootstrap/Nav';\nimport NavDropdown from 'react-bootstrap/NavDropdown';\n\nimport \"./styles/ControlBar.css\";\n\nexport const ControlBar = props => {\n    const { resetGrid, algorithm, resetAlgorithm, visualizeAlgorithm } = props;\n    const title = algorithm ? algorithm : \"Select Algorithm\";\n    return (\n        <Navbar collapseOnSelect expand=\"lg\" bg=\"dark\" variant=\"dark\" className=\"control-bar-container\">\n            <Navbar.Brand href=\"#\" className=\"control-bar-container-title\">Pathfinding Visualizer</Navbar.Brand>\n            <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\n            <Navbar.Collapse id=\"responsive-navbar-nav\">\n                <Nav className=\"mr-auto\">\n                    <NavDropdown title={title} id=\"collasible-nav-dropdown\" className=\"control-bar-button\" variant=\"outline-light\">\n                        <NavDropdown.Item onClick={() => resetAlgorithm('dijkstra')}>See Dijkstra's Algorithm</NavDropdown.Item>\n                        <NavDropdown.Item onClick={() => resetAlgorithm('dfs')}>See DFS Algorithm</NavDropdown.Item>\n                        <NavDropdown.Item onClick={() => resetAlgorithm('bfs')}>See BFS Algorithm</NavDropdown.Item>\n                    </NavDropdown>\n                    <Nav.Link className=\"control-bar-button\" onClick={() => visualizeAlgorithm()}>Start!</Nav.Link>\n                    <Nav.Link onClick={() => resetGrid()} className=\"control-bar-button\">Reset Grid</Nav.Link>\n                    <NavDropdown title=\"What's going on?\" id=\"collasible-nav-dropdown\" className=\"control-bar-button\">\n                        <NavDropdown.Item>Dijkstra's Algorithm</NavDropdown.Item>\n                        <NavDropdown.Item>DFS Algorithm</NavDropdown.Item>\n                        <NavDropdown.Item>BFS Algorithm</NavDropdown.Item>\n                    </NavDropdown>\n                </Nav>\n            </Navbar.Collapse>\n        </Navbar>\n    )\n}","import React from 'react';\nimport { FaRegStar } from 'react-icons/fa';\nimport { FiTarget } from 'react-icons/fi';\nimport './styles/InfoSection.css';\n\nexport const InfoSection = () => {\n    return (\n        <div className=\"info-section-container\">\n            <div>\n                <p>Starting node:</p>\n                <FaRegStar style={{ margin: \"2px 0 0 2px\", color: \"red\", fontSize: \"1.6rem\" }} />\n            </div>\n            <div>\n                <p>Finishing node:</p>\n                <FiTarget style={{ margin: \"2px 0 0 2px\", color: \"red\", fontSize: \"1.6rem\" }} />\n            </div>\n            <div>\n                <p>Normal node:</p>\n                <div className=\"node\"></div>\n            </div>\n            <div>\n                <p>Wall node:</p>\n                <div className=\"node node-wall\"></div>\n            </div>\n        </div>\n    )\n}","import React from 'react';\nimport { FaGithub, FaLinkedinIn } from 'react-icons/fa';\nimport \"./styles/Footer.css\";\n\nexport const Footer = () => {\n    return (\n        <footer>\n            <div className=\"footer-container\">\n                <ul className=\"footer-buttons\">\n                    <li>\n                        <a id=\"github\" href=\"https://github.com/jonathanthec\" target=\"_blank\" rel=\"noopener noreferrer\">\n                            <FaGithub style={{ fontSize: \"1.6rem\" }} />\n                        </a>\n                    </li>\n                    <li>\n                        <a id=\"linkedin\" href=\"https://www.linkedin.com/in/jonathan-chen-86589686/\" target=\"_blank\" rel=\"noopener noreferrer\">\n                            <FaLinkedinIn style={{ fontSize: \"1.6rem\" }} />\n                        </a>\n                    </li>\n                </ul>\n                <div className=\"footer-copyright\">\n                    <p><i className=\"fa fa-copyright\"></i> Jonathan Chen 2020</p>\n                </div>\n            </div>\n        </footer>\n    )\n}","// Dijkstra's algorithm will return all nodes that are visited\n// Order of visiting is top, right, bottom, left\n// All nodes point to their previous node, giving us the shortest path\n\nexport function dijkstra(grid, startNode, finishNode) {\n    // Keep track of a list of nodes that I have visited in order\n    const nodesVisitedInOrder = [];\n    // The distance to startNode from startNode is 0\n    startNode.distance = 0;\n    // Get all unvisited nodes in the grid (here it's all nodes)\n    const unvisitedNodes = getAllNodes(grid);\n    // Now, as long as we still have unvisited nodes in the above list\n    while (unvisitedNodes.length !== 0) {\n        // Sort the list of unvisited nodes to place the one with shortest distance \n        // In the front. This ensures startNode is at beginning. \n        sortNodesByDistance(unvisitedNodes);\n        // Returns the first node in the list unvisitedNodes and removes it from list\n        const closestNode = unvisitedNodes.shift();\n        // If a node is wall, continue\n        if (closestNode.isWall === true) continue;\n        // If a node's distance to startNode is infinity, we are done, no more places to go\n        if (closestNode.distance === Infinity) {\n            return nodesVisitedInOrder;\n        }\n        // Otherwise, do the following\n        closestNode.visited = true;\n        nodesVisitedInOrder.push(closestNode);\n        if (closestNode === finishNode) {\n            return nodesVisitedInOrder;\n        }\n        // See what are the neighbors of closestNode, and update their distance to startNode\n        updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n\nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n        for (const node of row) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisited = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisited) {\n        neighbor.distance = node.distance + 1;\n        neighbor.previousNode = node;\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nfunction getShortestNodePath(finishNode) {\n    const shortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\nfunction animateDijkstra(orderedVisitedNodes, orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedVisitedNodes.length; i++) {\n        if (i === orderedVisitedNodes.length - 1) {\n            setTimeout(() => {\n                animateShortestPath(orderedNodesOnShortestPath);\n            }, 10 * i);\n        }\n        setTimeout(() => {\n            const node = orderedVisitedNodes[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n    }\n}\n\nfunction animateShortestPath(orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedNodesOnShortestPath.length; i++) {\n        setTimeout(() => {\n            const node = orderedNodesOnShortestPath[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }, 50 * i)\n    }\n}\n\nexport function visualizeDijkstra(grid, startRow, startCol, finishRow, finishCol) {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const orderedVisitedNodes = dijkstra(grid, startNode, finishNode);\n    const orderedNodesOnShortestPath = getShortestNodePath(finishNode);\n    animateDijkstra(orderedVisitedNodes, orderedNodesOnShortestPath);\n}","// Breadth first search algorithm will start at a node, list all\n// of the node's neighbors in an array, and check each of the neighbors, \n// while adding neighbor's neighbors in the list\n// Does not guarantee the shortest path for obvious reason\n\nexport function bfs(grid, startNode, finishNode) {\n    // Initialize an empty array to track nodes that I will be visiting in order\n    const nodesVisitedInOrder = [];\n    // Initialize an empty queue, this will keep track all the nodes we haven't visit yet\n    const unvisitedNeighbors = [];\n    // And push startNode to it, because we will start at startNode\n    unvisitedNeighbors.push(startNode);\n    let times = 0;\n    // As long as finishNode isn't found, we'll keep searching until there are no more things to look for\n    while (unvisitedNeighbors.length > 0) {\n        times++;\n        // Grab the first node on unvisitedNeighbors, and its row and col\n        const currNode = unvisitedNeighbors.shift();\n        if (currNode.isWall) continue;\n        if (!currNode.visited) {\n            currNode.visited = true;\n            nodesVisitedInOrder.push(currNode);\n        }\n        // Now, if currNode is the finishNode, we are done\n        if (currNode === finishNode) {\n            console.log(times)\n            return nodesVisitedInOrder;\n        }\n        // Otherwise we need to push its unvisited neighbors to unvisitedNeighbors\n        const neighbors = getUnvisitedNeighbors(currNode, grid);\n        for (let i = 0; i < neighbors.length; i++) {\n            if (neighbors[i].visited === false && !unvisitedNeighbors.includes(neighbors[i])) {\n                neighbors[i].previousNode = currNode;\n                unvisitedNeighbors.push(neighbors[i]);\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nfunction getShortestNodePath(finishNode) {\n    const shortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\nfunction animateBfs(orderedVisitedNodes, orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedVisitedNodes.length; i++) {\n        if (i === orderedVisitedNodes.length - 1) {\n            setTimeout(() => {\n                animateShortestPath(orderedNodesOnShortestPath);\n            }, 10 * i);\n        }\n        setTimeout(() => {\n            const node = orderedVisitedNodes[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n    }\n}\n\nfunction animateShortestPath(orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedNodesOnShortestPath.length; i++) {\n        setTimeout(() => {\n            const node = orderedNodesOnShortestPath[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }, 50 * i)\n    }\n}\n\nexport function visualizeBfs(grid, startRow, startCol, finishRow, finishCol) {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const orderedVisitedNodes = bfs(grid, startNode, finishNode);\n    const orderedNodesOnShortestPath = getShortestNodePath(finishNode);\n    animateBfs(orderedVisitedNodes, orderedNodesOnShortestPath);\n}","// Depth first search algorithm will start at startNode, and add all of its valid neighbors\n// To an array called toBeVisitedNodes. Order of adding neighbors will be top, right, bottom, left.\n// It will then check for the last element in the array.\n// Does not guarantee shortest path.\n\nexport function dfs(grid, startNode, finishNode) {\n    const toBeVisitedNodes = [];\n    const nodesVisitedInOrder = [];\n    toBeVisitedNodes.push(startNode);\n\n    while (toBeVisitedNodes.length > 0) {\n        const currNode = toBeVisitedNodes.pop();\n        if (currNode.isWall === true) continue;\n        if (!currNode.visited) {\n            currNode.visited = true;\n            nodesVisitedInOrder.push(currNode);\n        }\n        if (currNode === finishNode) {\n            return nodesVisitedInOrder;\n        }\n        const neighbors = getUnvisitedNeighbors(currNode, grid);\n        for (const neighbor of neighbors) {\n            if (!toBeVisitedNodes.includes(neighbor)) {\n                neighbor.previousNode = currNode;\n                toBeVisitedNodes.push(neighbor);\n            }\n        }\n    }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const { row, col } = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    return neighbors.filter(neighbor => !neighbor.visited);\n}\n\nfunction getShortestNodePath(finishNode) {\n    const shortestPath = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n        shortestPath.unshift(currentNode);\n        currentNode = currentNode.previousNode;\n    }\n    return shortestPath;\n}\n\n\nfunction animateDfs(orderedVisitedNodes, orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedVisitedNodes.length; i++) {\n        if (i === orderedVisitedNodes.length - 1) {\n            setTimeout(() => {\n                animateShortestPath(orderedNodesOnShortestPath);\n            }, 10 * i);\n        }\n        setTimeout(() => {\n            const node = orderedVisitedNodes[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-visited';\n        }, 10 * i);\n    }\n}\n\nfunction animateShortestPath(orderedNodesOnShortestPath) {\n    for (let i = 0; i < orderedNodesOnShortestPath.length; i++) {\n        setTimeout(() => {\n            const node = orderedNodesOnShortestPath[i];\n            document.getElementById(`node-${node.row}-${node.col}`).className = 'node node-shortest-path';\n        }, 50 * i)\n    }\n}\n\nexport function visualizeDfs(grid, startRow, startCol, finishRow, finishCol) {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const orderedVisitedNodes = dfs(grid, startNode, finishNode);\n    const orderedNodesOnShortestPath = getShortestNodePath(finishNode);\n    animateDfs(orderedVisitedNodes, orderedNodesOnShortestPath);\n}","import React, { useState, useEffect } from 'react';\nimport { Node } from './Node.js';\nimport { ControlBar } from './ControlBar.js';\nimport { InfoSection } from './InfoSection.js';\nimport { Footer } from './Footer.js';\nimport { visualizeDijkstra } from '../algorithms/dijkstra';\nimport { visualizeBfs } from '../algorithms/bfs';\nimport { visualizeDfs } from '../algorithms/dfs';\nimport './styles/MazeSolver.css';\n\nexport default function MazeSolver() {\n    const [grid, setGrid] = useState([]);\n    const [mouseIsPressed, setMouseIsPressed] = useState(false);\n    const [dragStart, setDragStart] = useState(false);\n    const [dragFinish, setDragFinish] = useState(false);\n    const [startRow, setStartRow] = useState(NODE_START_ROW);\n    const [startCol, setStartCol] = useState(NODE_START_COL);\n    const [finishRow, setFinishRow] = useState(NODE_FINISH_ROW);\n    const [finishCol, setFinishCol] = useState(NODE_FINISH_COL);\n    const [algorithm, setAlgorithm] = useState(null);\n\n    useEffect(() => {\n        const grid = initializeGrid();\n        setGrid(grid);\n    }, [])\n\n    function resetGrid() {\n        for (let row = 0; row < 25; row++) {\n            for (let col = 0; col < 50; col++) {\n                document.getElementById(`node-${row}-${col}`).className = 'node';\n            }\n        }\n        const newGrid = initializeGrid();\n        setGrid(newGrid);\n        setStartRow(NODE_START_ROW);\n        setStartCol(NODE_START_COL);\n        setFinishRow(NODE_FINISH_ROW);\n        setFinishCol(NODE_FINISH_COL);\n    }\n\n    function resetAlgorithm(str) {\n        setAlgorithm(str);\n    }\n\n    function handleMouseDown(row, col) {\n        if (grid[row][col].isStart) {\n            setDragStart(true);\n            setMouseIsPressed(true);\n        }\n        if (grid[row][col].isFinish) {\n            setDragFinish(true);\n            setMouseIsPressed(true);\n        }\n        if (!grid[row][col].isFinish && !grid[row][col].isStart) {\n            const newGrid = initializeGridWithWall(grid, row, col);\n            setGrid(newGrid);\n            setMouseIsPressed(true);\n        }\n    }\n\n    function handleMouseEnter(row, col) {\n        if (!mouseIsPressed && !dragStart && !dragFinish) return;\n        if (dragStart) {\n            const newGrid = initializeGridWithNewStart(grid, row, col);\n            setGrid(newGrid);\n            setStartRow(row);\n            setStartCol(col);\n        }\n        if (dragFinish) {\n            const newGrid = initializeGridWithNewFinish(grid, row, col);\n            setGrid(newGrid);\n            setFinishRow(row);\n            setFinishCol(col);\n        }\n        if (!dragStart && !dragFinish) {\n            const newGrid = initializeGridWithWall(grid, row, col);\n            setGrid(newGrid);\n        }\n    }\n\n    function handleMouseLeave(row, col) {\n        if (dragStart) {\n            const newGrid = initializeGridWithNewStart(grid, row, col);\n            setGrid(newGrid);\n        }\n        if (dragFinish) {\n            const newGrid = initializeGridWithNewFinish(grid, row, col);\n            setGrid(newGrid);\n        }\n        if (!dragStart && !dragFinish) {\n            return;\n        }\n    }\n\n    function handleMouseUp() {\n        setMouseIsPressed(false);\n        setDragStart(false);\n        setDragFinish(false);\n    }\n\n    function visualizeAlgorithm() {\n        if (algorithm === 'dijkstra') {\n            visualizeDijkstra(grid, startRow, startCol, finishRow, finishCol);\n        }\n        if (algorithm === 'bfs') {\n            visualizeBfs(grid, startRow, startCol, finishRow, finishCol);\n        }\n        if (algorithm === 'dfs') {\n            visualizeDfs(grid, startRow, startCol, finishRow, finishCol);\n        }\n    }\n\n    return (\n        <div className=\"page-container\">\n            <ControlBar\n                resetGrid={resetGrid}\n                resetAlgorithm={resetAlgorithm}\n                algorithm={algorithm}\n                visualizeAlgorithm={visualizeAlgorithm}\n            />\n            <div className=\"page-main\"> {/************ START OF MAIN CONTENT ************/}\n                <InfoSection />\n                <div className=\"grid\">\n                    {grid && grid.map((row, rowIdx) => {\n                        return (\n                            <div key={rowIdx} className=\"grid-row\">\n                                {row.map((node, nodeIdx) => {\n                                    const { row, col, isStart, isFinish, isWall } = node;\n                                    return (\n                                        <Node\n                                            key={nodeIdx}\n                                            row={row}\n                                            col={col}\n                                            isStart={isStart}\n                                            isFinish={isFinish}\n                                            isWall={isWall}\n                                            mouseIsPressed={mouseIsPressed}\n                                            onMouseDown={(row, col) => handleMouseDown(row, col)}\n                                            onMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                                            onMouseLeave={(row, col) => handleMouseLeave(row, col)}\n                                            onMouseUp={() => handleMouseUp()}\n                                        />\n                                    )\n                                })}\n                            </div>\n                        );\n                    })}\n                </div>\n            </div> {/************ END OF MAIN CONTENT ************/}\n            <Footer />\n        </div>\n    )\n}\n\nconst NODE_START_ROW = 0\nconst NODE_START_COL = 0;\nconst NODE_FINISH_ROW = 12;\nconst NODE_FINISH_COL = 12;\n\nfunction initializeGrid() {\n    const grid = [];\n    for (let row = 0; row < 25; row++) {\n        const currentRow = [];\n        for (let col = 0; col < 50; col++) {\n            currentRow.push(createNode(row, col));\n        }\n        grid.push(currentRow);\n    }\n    return grid;\n}\n\nfunction createNode(row, col) {\n    return {\n        row,\n        col,\n        isStart: row === NODE_START_ROW && col === NODE_START_COL,\n        isFinish: row === NODE_FINISH_ROW && col === NODE_FINISH_COL,\n        isWall: false,\n        visited: false,\n        distance: Infinity,\n        previousNode: null\n    }\n}\n\nconst initializeGridWithWall = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    if (!node.isStart && !node.isFinish) {\n        const newNode = {\n            ...node,\n            isWall: !node.isWall,\n        };\n        newGrid[row][col] = newNode;\n    }\n    return newGrid;\n};\n\nconst initializeGridWithNewStart = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isStart: !node.isStart,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n};\n\nconst initializeGridWithNewFinish = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n        ...node,\n        isFinish: !node.isFinish,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n};","import React from 'react';\nimport MazeSolver from './components/MazeSolver.js';\n\nfunction App() {\n  return (\n    <MazeSolver />\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}